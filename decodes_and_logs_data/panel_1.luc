//APA 102 led strips receive data as follows
//  Start frame 32 bits ZEROS
// LED FRAME consists of three bits 111.... and 5 bits brightnes value followed by one byte each blue, green, red..
// end frame is 4 bytes 8hFF.


module panel_1 (
    input clk,  // clock
    input rst,
    input x[11],
    input y[11],
    input active,
    input red[8],
    input green[8],
    input blue[8],
    input tx_busy,
    

    input gameCounter2[26],

    output ledOut,
    output transmitByte[8],
    output newDataFlag,
    
    input spiBusySignal,
    output newSpiData,
    output ledByteOut[8]
  ) {
  
  //const PANEL_SIZE = 680; //34 x 20 +1
  
  //sig panel1red[PANEL_SIZE][8];
  //sig panel1green[PANEL_SIZE][8];
  //sig panel1blue[PANEL_SIZE][8];
  
  dff blinkFlag[2](.clk(clk));
  
  
  //dff xPixel[11](.clk(clk));
  //dff yPixel[11](.clk(clk));

  //dff ledPanelActive[10](.clk(clk));
    
  dff pixelInCounter[10](.clk(clk));
  
  dff ledWriteCounter[3](.clk(clk));
  dff ledStartBitCounter[4](.clk(clk));
  dff rgbCounter[4](.clk(clk));
  
  //dff greenCounter[3](.clk(clk));
  //dff blueCounter[3](.clk(clk));
  
  .clk(clk) {
    .rst(rst) {
      fsm state = {IDLE, READ, WRITE}; // our state machine
      fsm writeStep = {IDLE, START, LEDS, END};
    }
 
    dff pixelAddress[10]; // 10 allows for 2^10 = 1023 bytes... we need 680 per color per panel
    // we need our RAM to have an entry for every value of name_count
    simple_ram redRam (#SIZE(8), #DEPTH($pow(2,pixelAddress.WIDTH)));
    simple_ram blueRam (#SIZE(8), #DEPTH($pow(2,pixelAddress.WIDTH)));
    simple_ram greenRam (#SIZE(8), #DEPTH($pow(2,pixelAddress.WIDTH)));
    
  }
  

  always {
    
    redRam.address = pixelAddress.q;
    greenRam.address = pixelAddress.q;
    blueRam.address = pixelAddress.q;
    redRam.write_data = 8hxx;
    greenRam.write_data = 8hxx;
    blueRam.write_data = 8hxx;
    redRam.write_en = 0;
    greenRam.write_en = 0;
    blueRam.write_en = 0;

    newDataFlag = 0;
    transmitByte = 0;
    
    ledOut = 0;
    
    ledByteOut = 0;
    newSpiData = 0;
    

    case (state.q) { // our FSM
      // IDLE: Reset everything and wait for a new byte.
      state.IDLE:
        //newDataFlag = 0;
        pixelInCounter.d = 0;
 
      // PROMPT: Print out name prompt.
      state.READ:
        redRam.write_data = red;
        greenRam.write_data = green;
        blueRam.write_data = blue;
        redRam.write_en = 1;
        greenRam.write_en = 1;
        blueRam.write_en = 1;
        pixelInCounter.d = pixelInCounter.q + 1;
        
        // PROMPT: Print out name prompt.
      state.WRITE:
        //if(ledWriteCounter.q == 0) 
          //writeStep.d = writeStep.START;
        if(ledStartBitCounter.q < 5 && !spiBusySignal)  //send atleast 32 0s first
        {  
          ledByteOut = 8b0;
          newSpiData = 1;
          ledStartBitCounter.d = ledStartBitCounter.q + 1;
          pixelAddress.d = 0;
          rgbCounter.d = 0;
          
        }
        if(ledStartBitCounter.q == 5 && !spiBusySignal) //1st led frame
        { 
          transmitByte = pixelAddress.q;
          newDataFlag = 1;
          if(rgbCounter.q == 0)
          {
            ledByteOut = 8he7; //1st led frame
            newSpiData = 1;
            rgbCounter.d = rgbCounter.q + 1;
          }
          if(rgbCounter.q == 1)
          { 
            ledByteOut = blueRam.read_data;
            newSpiData = 1;
            rgbCounter.d = rgbCounter.q + 1;
          }          
          if(rgbCounter.q == 2)
          { 
            ledByteOut = greenRam.read_data;
            newSpiData = 1;
            rgbCounter.d = rgbCounter.q + 1;
          }  
          if(rgbCounter.q == 3)
          { 
            ledByteOut = redRam.read_data;
            newSpiData = 1;
            rgbCounter.d = 0;
            pixelAddress.d = pixelAddress.q + 1;
          }            
         
          if(pixelAddress.q == d680)
          {
            ledStartBitCounter.d = ledStartBitCounter.q + 1;
          }
        }
        if(ledStartBitCounter.q > 5 && ledStartBitCounter.q < 10 && !spiBusySignal) //end frame 4 bytes of 8hFF
        {  
          ledByteOut = 8hff;
          newSpiData = 1;
          ledStartBitCounter.d = ledStartBitCounter.q + 1;
        } 
        if(ledStartBitCounter.q > 10)
        {
          state.d = state.IDLE;
          writeStep.d = writeStep.IDLE;
          ledStartBitCounter.d = 0;
        }        
        
        
    } 
    
 
    case (writeStep.q) { // our FSM
      // 
      writeStep.IDLE:
        ledOut = 0;
        
      writeStep.START:
        ledOut = 0;
    } 
          
      // PROMPT: Print out name prompt.
      //state.READ:
    
    
    
       
    if(x > 30 && x < 250 && active && blinkFlag.q == 0 && gameCounter2[25] == 1) // && xPixel.q > 40 && xPixel.q < 448 && active && blinkFlag.q == 0)
    {
      //ledOut = 1;
      if(red > 30)
      {
        if(!&blinkFlag.q)
        {
          blinkFlag.d = blinkFlag.q + 1;
        }
        ledOut = 1;
      }
      
    }
    
    if(x >= 40 && x < 74 && y >= 30 && y < 50 && active) //panel 1 ... #1 panel is 34 pixels wide x 20 deep
    {    
      state.d = state.READ;
    }else{
      //ledPanelActive.d[0] = 0;
    }
    
//    if(ledPanelActive.q[0] == 1)
//    {
      
      //pixelCount.d = pixelCount.q + 1;
      //greenCounter.d = pixelCounter.q + 1;
      //blueCounter.d = pixelCounter.q + 2;
      //panel1red[pixelCounter.q] = red;
      //panel1green[greenCounter.q] = green;
      //panel1blue[blueCounter.q] = blue;
//    }
    
    if(pixelInCounter.q == d680) 
    {
      state.d = state.WRITE;
      ledWriteCounter.d = 0;
      ledStartBitCounter.d = 0;
      rgbCounter.d = 0;
      pixelInCounter.d = pixelInCounter.q + 1; //not sure if this is needed... my head is still in c++
    }    
    

    if(y == d330) 
    {
      //pixelAddress.d = d660;
      if(!tx_busy)
      {
      //transmitByte = redRam.read_data;
      //newDataFlag = 1;
      }
    }
    if(y == d380) 
    {
      //pixelAddress.d = d660;
      if(!tx_busy)
      {
      //transmitByte = greenRam.read_data;
      //newDataFlag = 1;
    }
    }    
    if(y == d450) 
    {
      //pixelAddress.d = d660;
      if(!tx_busy)
      {
      //transmitByte = blueRam.read_data;
      //newDataFlag = 1;
    }
    }  
    
    
    //if(y == d600) 
    //{
   // pixelInCounter.d = 0;
    //}    
    

    
  }
}
