// sets display area to x,y   
// x from 40 to 448
// y from 30 to 250

//draggin the mouse over a blue screen causes the 2nd LED (led[1]) to turn ON

//had to edit HDMI_decoder as it didn't work... imported dvi_decoder directly... not sure 
//not sure if I need to run the clock at 100mhz..



module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    
    
    
    
    input hdmi2_tmds [4],   // HDMI In
    input hdmi2_tmdsb [4],
    inout hdmi2_sda,        // EDID Interface
    input hdmi2_scl
    
    
    
  ) {
  
  sig rst;  // reset signal
  sig fclk; // 100MHz clock
 
  // boost clock to 100MHz
  clk_wiz_v3_6 clk_wiz;
  always {
    clk_wiz.CLK_IN1 = clk;   // 50MHz in
    fclk = clk_wiz.CLK_OUT1; // 100MHz out (it's like magic!)
  }
  
  .clk(fclk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    // connect up the edid rom using a clock we know will alway be running
    edid_rom edid (.rst(rst), .sda(hdmi2_sda), .scl(hdmi2_scl));
    
     
    
    dff gameCounter[26];
    dff blinkFlag[2];
    
    
    
  }
  
  
  //hdmi_decoder hdmi_in (.rst(0));
  dvi_decoder hdmi_in (.rst(rst));
  
  .clk(hdmi_in.pclk) {
    dff x_ctr[11];
    dff y_ctr[11];
    //edge_detector hedge (#RISE(1), #FALL(0));
    
    dff red[8];
    dff green[8];
    dff blue[8];
    
    dff vFlag[2];
    
    
  }
  
  always {
    reset_cond.in = ~rst_n;    // input raw inverted reset signal
    rst = reset_cond.out;      // conditioned reset
 
    spi_miso = bz;             // not using SPI
    spi_channel = bzzzz;       // not using flags
    avr_rx = bz;               // not using serial port
    
    // connect HDMI input
    hdmi_in.tmds = hdmi2_tmds;
    hdmi_in.tmdsb = hdmi2_tmdsb;
    
    //hdmi_in.tmds = tmds;
    //decoder.tmdsb = tmdsb;
    
     
    // save colors
    red.d = hdmi_in.red;
    //green.d = hdmi_in.green;
    blue.d = hdmi_in.blue;
    
    //xPixel.d = hdmi_in.x;
    //yPixel.d = hdmi_in.y;
  
    gameCounter.d = gameCounter.q + 1;
    
    led[0] = gameCounter.q[25];    
    led[7:2] = y_ctr.q;
        
   //hedge.in = hdmi_in.hsync;
    
    if (hdmi_in.de) {
      x_ctr.d = x_ctr.q + 1;
      //y_ctr.d = y_ctr.q + 1;
      //if (hedge.out)
        //y_ctr.d = y_ctr.q + 1;
    }
    
    if(x_ctr.q > d800 && vFlag.q == 0) //goes up once every horizontal line arbitrary set at 800 pixels across (past the pixels we care about)
    {
      y_ctr.d = y_ctr.q + 1;
      if(!&vFlag.q)
      {
        vFlag.d = vFlag.q + 1;
      }
    }
    
    if(x_ctr.q == d750) //get the flag ready to increase vertical count by 1
    {
      vFlag.d = 0;
    }
    
    if(hdmi_in.hsync)
    {
      x_ctr.d = 0;
    }
    
    if (hdmi_in.vsync) {
      x_ctr.d = 0;
      y_ctr.d = 0;
      vFlag.d = 0;
    }


    if(y_ctr.q > 30 && y_ctr.q < 250 && x_ctr.q > 40 && x_ctr.q < 448 && hdmi_in.de && blinkFlag.q == 0)
    {
      if(red.q > 30)
      {
      if(gameCounter.q[25] == 1)
        {
          if(!&blinkFlag.q)
          {
            blinkFlag.d = blinkFlag.q + 1;
          }
          led[1] = 1;
        }else{
          led[1] = 0;
        }
      }
    }
    
    if(gameCounter.q[25] == 0)
    {
      blinkFlag.d = 0;
      led[1] = 0;
    } 

  }
}
  

  
