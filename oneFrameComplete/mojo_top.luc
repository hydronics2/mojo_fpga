// sets display area to x,y   
// x from 40 to 448
// y from 30 to 250

//draggin the mouse over the above acstive screen area the 2nd LED (led[1]) to turn ON

//had to edit HDMI_decoder as it didn't work... imported dvi_decoder directly... not sure 

//05/08/18 - took out 100mhz
//         - top sends x/y to panel #1 module. panel #1 counts pixels (680) and serial prints

//05/09/18 - logs rgb values to simple ram... writes to panel... 
//05/10/18 - logs first row across entire screen...and prints it to LED panel. ignoring small panel layout.
//05/13/18 - one frame working ... thanks to the gods...




module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,       // AVR RX buffer full
    
    
    
    
    input hdmi2_tmds [4],   // HDMI In
    input hdmi2_tmdsb [4],
    inout hdmi2_sda,        // EDID Interface
    input hdmi2_scl,
    
    
    output apa102_data,
    output apa102_sck
    
    
  ) {
  
  sig rst;  // reset signal

  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    
    // connect up the edid rom using a clock we know will alway be running
    edid_rom edid (.rst(rst), .sda(hdmi2_sda), .scl(hdmi2_scl));
    
    avr_interface avr(.rst(rst)); 
    
    dff gameCounter[26];
    dff blinkFlag[2];
    
 
  }
  
  dvi_decoder hdmi_in (.rst(rst));
  
  .clk(hdmi_in.pclk) {
    dff x_ctr[11];
    dff y_ctr[11];
    
    dff red[8];
    dff green[8];
    dff blue[8];
    
    dff vFlag[2];
    
    dff ledPanelActiveFlag[6]; //33 panels per mojo
    //dff ledPanelStartFlag[6];
    
    panel_1 panel_1(.rst(rst));
    spi_master2 spi_out(.rst(rst));
    
  }
  
  always {
    reset_cond.in = ~rst_n;    // input raw inverted reset signal
    rst = reset_cond.out;      // conditioned reset
 
    //spi_miso = bz;             // not using SPI
    //spi_channel = bzzzz;       // not using flags
    //avr_rx = bz;               // not using serial port
    
    // connect inputs of avr
    avr.cclk = cclk;
    avr.spi_ss = spi_ss;
    avr.spi_mosi = spi_mosi;
    avr.spi_sck = spi_sck;
    avr.rx = avr_tx;
    avr.channel = hf; // ADC is unused so disable
    avr.tx_block = avr_rx_busy; // block TX when AVR is busy
 
    // connect outputs of avr
    spi_miso = avr.spi_miso;
    spi_channel = avr.spi_channel;
    avr_rx = avr.tx;
    avr.new_tx_data = 0;
    avr.tx_data = 0;
    
    avr.tx_data = panel_1.transmitByte;
    avr.new_tx_data = panel_1.newDataFlag;
    panel_1.active = hdmi_in.de;
    panel_1.x = x_ctr.q;
    panel_1.y = y_ctr.q;
    panel_1.red = red.q;
    panel_1.green = green.q;
    panel_1.blue = blue.q;
    panel_1.gameCounter2 = gameCounter.q;
    panel_1.tx_busy = avr.tx_busy;
    panel_1.ledPanelActiveFlag = ledPanelActiveFlag.q;
    panel_1.ledPanelStartFlag = hdmi_in.vsync;
    
    
    
    // connect HDMI input
    hdmi_in.tmds = hdmi2_tmds;
    hdmi_in.tmdsb = hdmi2_tmdsb;
    
    
    spi_out.data_in = panel_1.ledByteOut;
    spi_out.start = panel_1.newSpiData; 
    panel_1.spiBusySignal = spi_out.busy;   
    
    spi_out.miso = 1b0;
    apa102_data = spi_out.mosi;
    apa102_sck = spi_out.sck;

    
     
    // save colors
    red.d = hdmi_in.red;
    green.d = hdmi_in.green;
    blue.d = hdmi_in.blue;
    
    gameCounter.d = gameCounter.q + 1;
    
    led[0] = gameCounter.q[25];  // this is a heart beat counter ~ 1 per second  
    led[7:3] = red.q;           //has a default blue screen... turns on pixels momentarily if there is red
        
    ledPanelActiveFlag.d = 0;
    
    if (hdmi_in.de) {
      x_ctr.d = x_ctr.q + 1;
    }
    
    if(x_ctr.q > d800 && vFlag.q == 0) //goes up once every horizontal line arbitrary set at 800 pixels across (past the pixels we care about)
    {
      y_ctr.d = y_ctr.q + 1;
      if(!&vFlag.q)
      {
        vFlag.d = vFlag.q + 1;
      }
    }
    
    if(x_ctr.q == d750) //get the flag ready to increase vertical count by 1
    {
      vFlag.d = 0;
    }
    
    if(hdmi_in.hsync)
    {
      x_ctr.d = 0;
    }
    
    if (hdmi_in.vsync) {
      x_ctr.d = 0;
      y_ctr.d = 0;
      vFlag.d = 0;
    }
    
    
    // if(x >= 40 && x < 74 && y >= 30 && y < 50 && active) //panel 1 ... #1 panel is 34 pixels wide x 20 deep
    
    //if(y_ctr.q > 30 && y_ctr.q < 250 && x_ctr.q > 40 && x_ctr.q < 448 && hdmi_in.de && blinkFlag.q == 0)
   
     if(x_ctr.q >= 40 && x_ctr.q < 74 && y_ctr.q >= 30 && y_ctr.q < 50 && hdmi_in.de && blinkFlag.q == 0) //panel 1
    {
      //ledPanelActive.d = 1;
      if(red.q > 30)
      {
      if(gameCounter.q[25] == 1)
        {
          if(!&blinkFlag.q)
          {
            blinkFlag.d = blinkFlag.q + 1;
          }
          led[1] = 1;
        }else{
          led[1] = 0;
        }
      }
    }
    


    if(x_ctr.q >= 40 && y_ctr.q >= 30 && hdmi_in.de) //panel 1 active flag
    {
      led[2] = 1;
      ledPanelActiveFlag.d[0] = 1;
    }
    else{
      
      led[2] = 0;
      ledPanelActiveFlag.d[0] = 0;
    }    
    
    
    if(gameCounter.q[25] == 0)
    {
      blinkFlag.d = 0;
      led[1] = 0;
    } 
    
   // if(x_ctr.q >= 40 && x_ctr.q < 74 && y_ctr.q >= 30 && y_ctr.q < 50 && hdmi_in.de) //tests if x and y are in the panel #1 active area
    //{    
      //ledPanelActive.d[0] = 1;
    //}else{
      //ledPanelActive.d[0] = 0;
    //}
  
  }
}

  
